# 代码整洁之道

## 第2章 有意义的命名

以数字系列命名（a1、a2...aN）是依义命名的对立面

这样的名称纯属误导

类名和对象名应该是名词或名词短语，不应当是动词

方法名应当是动词或动词短语

## 第3章 函数

函数第一规则是要短小，20行封顶最佳

if语句、else语句、while语句等，其中的代码块应该只有一行。改行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加文档上的价值。
这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层

函数应该做一件事。做好这一件事。只做这一件事

长而具有描述性的名称，要比短而令人费解的名称好，长而具有描述性的名称，要比描述性的长注释好

最理想的参数数量事零，其次是一，再次是二，应尽量避免三
有足够的特殊理由才能使用三个以上的参数

普遍而言，应避免使用输出参数。如果函数必须要修改某种状态，就修改所属对象的状态

分隔指令与询问

函数应该修改某对象的专改或者是返回该对象的有关信息，两样都干常会导致混乱

try/catch代码丑陋不堪。它们搞乱了代码结构，把错误处理与正常流程混为一谈。最好把try和catch代码块的主题部分抽离出来，另外形成函数

函数应该只做一件事，错误处理就是一件事。因此，处理u从无的函数不该做其他事。这意味着如果关键字try再某个函数中存在，它就该是这个函数的第一个单词，而且再catch/finally代码块后面也不该又其他内容

不需要一开始就按照规范写函数，而是先想什么就写什么，然后再打磨它。初稿也许粗陋无序，你就斟酌推敲，直至达到你心目中的样子

## 第4章 注释

注释的恰当用法是弥补我们在用代码表达意图时遭遇的失败。如果你发现自己需要写注释，再想想看是否有办法翻盘，用代码来表达

注释存在的时间越久，就离其所描述的代码越远，越来越变得全然错误。原因很简单，程序员不能坚持维护代码

TODO注释：TODO是一种程序员人为应该做，但由于某些原因目前还没做的工作

我们已经拥有良好的源代码控制系统如此之久，这些系统可以为我们记住不要的代码。我们无需再用注释来标记，删掉即可

## 第5章 格式

在封包声明、导入声明和每个函数之间，都有空白行隔开。这条极其简单的规则极大地影响到代码地视觉外观

紧密相关的代码应该互相靠近

变量声明：变量声明应尽可能靠近其使用位置

实体变量：实体变量应该在类的顶部声明

相关函数：若某个函数调用了另外一个，因应该把它们放在一起，而且调用者应该尽可能放在被调用者的上面。这样，程序就有一个自然的顺序。若坚定地遵循这条规则，读者将能够确信函数声明总会在其调用后很快出现

## 第6章 对象和数据结构

过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数。面向对象代码便于在不改动既有函数的铅锑钾添加新类。所以对于面向对象较难的事，对于过程式代码却较容易，反之亦然

得墨忒耳律 模块不应了解它所操作对象得内部情形（对象隐藏数据，暴露操作）

方法不应调用由任何函数返回的`对象`的方法（eg: a().b().c()，这类代码被称作火车失事）。这类一连串的调用通常被认为事肮脏的风格

## 第7章 错误处理

不要在函数中传递返回null

## 第8章 边界

## 第9章 单元测试

TDD三定律

1. 在编写不能通过的单元测试前，不可编写生产代码
2. 只编刚好无法通过的单元测试，不能编译也算不通过
3. 只可编写刚好足以通过当前失败测试的生产代码

整洁的测试

要素 可读性

规则

1. 快速
2. 独立
3. 可重复
4. 自足验证
5. 及时

## 第10章 类

单一权责原则（SRP）认为，类或模块应有且只有一条加以修改的理由

系统应该由许多短小的类而不是少量巨大的类组成。每个小类封装一个权责，只有一个修改的原因，并与少数其他类一起协同达成期望的系统行为

内聚

内聚性高，说明着类中的方法和变量互相依赖、互相结合成一个逻辑整体

## 第11章 系统

## 第12章 迭进

简单设计

1. 运行所有测试
2. 不可重复
3. 表达了程序员的意图
4. 尽可能减少类和方法的数量

## 第13章 并发编程

## 第14章 逐步改进

## 第15章 JUnit内幕

## 第16章 重构SerialDate

## 第17章 味道与启发

### 注释

1. **不恰当的信息** 通常，作者、最后修改时间、SPR数等元数据不该在注释中出现。注释只应该描述有关代码和设计的技术性信息

2. **废弃的注释** 如果发现废弃的注释，最好尽快更新或删除掉

3. **冗余注释** 如果注释描述的是某种充分自我描述了的东西，那么数据就是多余的

4. **注释掉的代码** 看到注释掉的代码，就删除它

### 函数

1. **过多的参数** 函数的参数数量应该少。没参数最好，一个次之，两个、三个再次之。三个以上的参数非常值得质疑，应坚决避免

2. **输出参数** 输出参数违反直觉。读者期望参数用于输入而非输出。如果函数非要修改什么东西的状态不可，就修改它所在的对象的状态好了

3. **参数标识** 布尔值参数大声宣告函数做了不止一件事。它们令人迷惑应该消灭掉

4. **死函数** 永不被调用的方法应该丢弃。保留死代码纯属浪费。别害怕删除函数。记住，源代码控制系统还会记得它

### 一般性问题

1. **一个源文件中存在多中语言** 理想的源文件包括且只包括一种语言。现实中，我们可能会不得不使用多余一种语言。但应该尽力减少源文件中额外语言的数量和范围

2. **明显的行为未被实现**

3. **不正确的边界行为** 每种边界条件、每种极端情形、每个异常都代表了某种肯恩搞乱优雅而直白的算法的东西。别依赖直觉，追索每种边界条件，编写测试

4. **重复**
本书提到的最重要的规则之一。每次看到重复代码，都代表遗漏了抽象。重复的代可能成为子程序或干脆是另一个类。将重复代码叠放进类似的抽象，增加了你的设计语言的词汇量。其他程序员可以用到你创建的抽象设施。编码变得越来越快，错误越来越少，因为你提升了抽象层级
重复最明显的形态是你不断看到明显一样的代码。可以用单一方法来替代之。
较隐蔽的形态是在不同的模块中不断重复出现、检测同一组条件的switch/case或if/else链。可以用**多态**来替代之。更隐蔽的形态是采用类似算法但具体代码行不同的模块。这也是一种重复，可以使用**模板方法模式**或**策略模式**来修正

5. **在错误的抽象层级上的代码** 创建分离较高层级一般性概念与较低层级细节概念的抽象模型。例如，只与细节实现有关的常量，变量或工具函数不应该出现在基类中出现，基类应该对这些东西一无所知

6. **基类依赖于派生类** 将概念分解到基类和派生类的最普遍的原因是较高层级基类概念可以不依赖于较低层级派生类的概念。这样，如果看到基类提到派生类名称，就可能发现了问题

7. **信息过多** 设计良好的模块有着非常小的接口，让你事半功倍，设计低劣的模块有着广阔、深入的接口，你不得不事倍功半。类中的方法越少越好。函数之道的变量越少越好。类拥有的实体变量越少越好

8. **死代码** 死代码就是不执行的代码。可以在检查不会发生的条件if语句体中找到。可以在从不抛出异常的try语句的catch块中找到。可以在从不被调用的小工具方法中找到，也可以在不会发生的switch/case条件中找到。死代码的问题事过不久它就会发出臭味。这是因为，在设计改变时，死代码不会随之更新。它还能通过编译，但并不会遵循较新的约定或规则。它编写的时候，系统时另一番模样。

9. **垂直分隔** 变量的函数应该在靠近被使用的地方定义。本地变量应该正好在其首次被使用的位置上面声明，垂直距离要短。私有函数应该刚好在其首次被使用的位置下面定义。私有函数属于整个类，但我们还是要限制调用和定义之间的垂直距离

10. **选择算子参数** 没有什么比在函数调用魔为遇到一个false参数更为可憎的事情了。不仅是一个选择算子参数的的目的难以记住，每个选择算子参数将多个函数绑到了一起。选择算子参数只是一种避免把大函数切分为多个小函数的偷懒做法。当然，选择算子不一定是boolean类型。可能是枚举元素、整数或任何一种用于选择函数行为的参数。使用多个参数，通常优于向单个函数传递代码来选择函数行为

11. **使用解释性变量** 解释性变量多比少好。只要把计算过程打散成一系列良好命名的中间值，不透明的模块就会突然变得透明

12. **函数名称应该表达其行为**

13. **用命名常量代替魔术数** 在代码中出现原始形态数字通常来说是坏现象，应该用良好命名的常量来隐藏它。

14. **封装条件** 如果没有if或while语句的上下文，布尔逻辑就难以理解，应该把解释了条件意图的函数抽离出来

    ```js
    if (shouldBeDeleted(timer))

    好于

    if (timer.hasExpierd() && !timer.isRecurrent())
    ```

15. **避免否定性条件**

16. **函数只该做一件事**

### 名称

1. **采用描述性名称**

2. **名称应该说明副作用**

### 测试
